--- a/.gitignore
+++ b/.gitignore
@@ -1 +1,19 @@
+/.idea/
+/.vscode/
+
+__pycache__/
+*.py[cod]
+*$py.class
+
+.env
+
+venv/
+.venv/
+env/
+ENV/
+
+build/
+dist/
+*.egg-info/
+
+*.log
+
--- /dev/null
+++ b/.env.example
@@ -0,0 +1,2 @@
+BOT_TOKEN="12345:your_telegram_bot_token_here"
+ADMIN_TELEGRAM_IDS="123456789" # Comma-separated list of admin Telegram IDs
--- /dev/null
+++ b/backend/src/__main__.py
@@ -0,0 +1,46 @@
+import asyncio
+import logging
+
+from aiogram import Bot, Dispatcher
+from aiogram.fsm.storage.redis import RedisStorage
+from redis.asyncio.client import Redis
+
+from .bot.handlers import admin, respondent
+from .bot.middlewares.auth import AdminAuthMiddleware
+from .config import settings
+
+
+async def main():
+    """
+    Application entry point.
+    """
+    logging.basicConfig(
+        level=logging.INFO,
+        format="%(asctime)s - %(levelname)s - %(name)s - %(message)s",
+    )
+
+    # Initialize Bot and Dispatcher
+    bot = Bot(token=settings.BOT_TOKEN, parse_mode="HTML")
+
+    # Initialize Redis storage
+    redis_client = Redis.from_url("redis://localhost:6379/0")
+    storage = RedisStorage(redis=redis_client)
+
+    dp = Dispatcher(storage=storage)
+
+    # Register middlewares
+    dp.message.middleware(AdminAuthMiddleware(settings.ADMIN_TELEGRAM_IDS))
+
+    # Register routers
+    dp.include_router(admin.router)
+    dp.include_router(respondent.router)
+
+    # Start polling
+    try:
+        await dp.start_polling(bot)
+    finally:
+        await bot.session.close()
+
+
+if __name__ == "__main__":
+    asyncio.run(main())
--- /dev/null
+++ b/backend/src/bot/handlers/admin.py
@@ -0,0 +1,14 @@
+from aiogram import Router, types
+from aiogram.filters import Command
+
+router = Router()
+
+# This router should be protected by the AdminAuthMiddleware
+
+
+@router.message(Command("new_cycle"))
+async def cmd_new_cycle(message: types.Message):
+    """
+    Handler for the /new_cycle command. Starts the cycle creation FSM.
+    """
+    await message.answer("Starting new feedback cycle creation...")
+    # TODO: Start FSM for cycle creation
--- /dev/null
+++ b/backend/src/bot/handlers/respondent.py
@@ -0,0 +1,14 @@
+from aiogram import F, Router, types
+from aiogram.filters import CommandStart
+
+router = Router()
+
+
+@router.message(CommandStart(deep_link=True))
+async def cmd_start_with_token(message: types.Message):
+    """
+    Handler for start links with a feedback token.
+    e.g., t.me/bot?start=<token>
+    """
+    token = message.text.split(" ")[1]
+    await message.answer(f"Welcome! You are starting feedback with token: {token}")
+    # TODO: Validate token and start questionnaire FSM
--- /dev/null
+++ b/backend/src/bot/middlewares/auth.py
@@ -0,0 +1,23 @@
+from typing import Any, Awaitable, Callable, Dict, List
+
+from aiogram import BaseMiddleware
+from aiogram.types import Message
+
+
+class AdminAuthMiddleware(BaseMiddleware):
+    def __init__(self, admin_ids: List[int]):
+        self.admin_ids = admin_ids
+
+    async def __call__(
+        self,
+        handler: Callable[[Message, Dict[str, Any]], Awaitable[Any]],
+        event: Message,
+        data: Dict[str, Any],
+    ) -> Any:
+        # This is a simplified example.
+        # In a real app, you'd apply this middleware only to admin handlers.
+        if event.from_user.id not in self.admin_ids:
+            # You can ignore the update or send a message.
+            # For admin commands, ignoring is often better.
+            return
+        return await handler(event, data)
--- /dev/null
+++ b/backend/src/bot/states/cycle_creation.py
@@ -0,0 +1,11 @@
+from aiogram.fsm.state import State, StatesGroup
+
+
+class CycleCreationFSM(StatesGroup):
+    """
+    FSM for the new feedback cycle creation process.
+    """
+    waiting_for_target_employee = State()
+    waiting_for_respondents = State()
+    waiting_for_deadline = State()
+    confirming_creation = State()
--- /dev/null
+++ b/backend/src/config.py
@@ -0,0 +1,16 @@
+from typing import List
+
+from pydantic import Field
+from pydantic_settings import BaseSettings, SettingsConfigDict
+
+
+class Settings(BaseSettings):
+    model_config = SettingsConfigDict(
+        env_file=".env", env_file_encoding="utf-8", extra="ignore"
+    )
+
+    BOT_TOKEN: str
+    ADMIN_TELEGRAM_IDS: List[int] = Field(default_factory=list)
+
+
+settings = Settings()
--- /dev/null
+++ b/backend/src/services/cycle_service.py
@@ -0,0 +1,10 @@
+from datetime import date
+from typing import List
+
+
+async def create_new_cycle(
+    target_id: str, respondent_ids: List[str], deadline: date
+):
+    """Placeholder for cycle creation logic."""
+    print(f"Creating cycle for {target_id} with {len(respondent_ids)} respondents.")
+    # TODO: Implement logic to create cycle in Redis and Google Sheets
--- /dev/null
+++ b/backend/src/services/google_sheets.py
@@ -0,0 +1,7 @@
+from typing import List, Dict, Any
+
+
+async def get_all_employees() -> List[Dict[str, Any]]:
+    """Placeholder for fetching employees from Google Sheets."""
+    print("Fetching employees from Google Sheets...")
+    return []
--- /dev/null
+++ b/backend/src/services/question_service.py
@@ -0,0 +1,7 @@
+from typing import List
+from ..storage.models import Question
+
+
+async def get_questions() -> List[Question]:
+    """Placeholder for fetching questions from Google Sheets."""
+    print("Fetching questions from Google Sheets...")
+    return []
--- /dev/null
+++ b/backend/src/storage/models.py
@@ -0,0 +1,38 @@
+from datetime import date, datetime
+from typing import Dict, List, Literal, Optional
+
+from pydantic import BaseModel, Field
+
+
+class Question(BaseModel):
+    id: str
+    text: str
+    type: Literal["scale", "text"]
+
+
+class Employee(BaseModel):
+    id: str = Field(alias="Employee_ID")
+    full_name: str = Field(alias="Full_Name")
+    telegram_id: int = Field(alias="Telegram_ID")
+    position: str = Field(alias="Position")
+    manager_id: Optional[str] = Field(alias="Manager_ID")
+
+
+class RespondentInfo(BaseModel):
+    id: str
+    status: Literal["pending", "completed"] = "pending"
+    token: str
+
+
+class FeedbackCycle(BaseModel):
+    id: str
+    target_employee_id: str
+    respondents: Dict[str, RespondentInfo]  # key: respondent_id
+    deadline: date
+    status: Literal["active", "closed", "reported"] = "active"
+    created_at: datetime = Field(default_factory=datetime.utcnow)
+
+
+class FeedbackDraft(BaseModel):
+    cycle_id: str
+    respondent_id: str
+    answers: Dict[str, int | str] = {}  # key: question_id
--- /dev/null
+++ b/backend/tests/test_example.py
@@ -0,0 +1,5 @@
+import pytest
+
+
+def test_initial():
+    """A simple placeholder test."""
+    assert True
--- /dev/null
+++ b/infra/terraform/.gitkeep
@@ -0,0 +1 @@
+
--- /dev/null
+++ b/pyproject.toml
@@ -0,0 +1,26 @@
+[tool.poetry]
+name = "360feedback-bot"
+version = "0.1.0"
+description = "Telegram bot for 360-degree feedback collection"
+authors = ["Your Name <you@example.com>"]
+readme = "README.md"
+packages = [{include = "src", from = "backend"}]
+
+[tool.poetry.dependencies]
+python = "^3.13"
+aiogram = "^3.7.0"
+pydantic = "^2.7.4"
+pydantic-settings = "^2.3.3"
+gspread = "^6.0.2"
+google-auth-oauthlib = "^1.2.0"
+redis = {version = "^5.0.5", extras = ["hiredis"]}
+apscheduler = "^3.10.4"
+tenacity = "^8.4.1"
+
+[tool.poetry.group.dev.dependencies]
+pytest = "^8.2.2"
+
+[build-system]
+requires = ["poetry-core"]
+build-backend = "poetry.core.masonry.api"
+
--- /dev/null
+++ b/scripts/.gitkeep
@@ -0,0 +1 @@
+